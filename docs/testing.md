## Purpose

This document describes our approach to testing for the 10101 project.

## Assumptions

Here we list a non-exhaustive set of assumptions that influenced our findings:

### Common Rust code between `app` and `coordinator`

There will be a number of crates that will be used as dependencies in both `app` and `coordinator`.

### No initial effort to keep different versions of `app` and `coordinator` compatible

The `coordinator` will not be backwards-compatible with older versions of the `app` until later in the development of 10101.
This means that we will not devote effort to test backwards compatibility between these two systems.

### The `coordinator` is treated as a single, multi-purpose system

In the past, we have modularised `coordinator`-like systems into several components for architectural and strategic reasons.
That may very well still be the case for 10101, but at this stage we lack the insight to split this system.
Once that design has been completed we can revise this document accordingly.

### Common `10101-lightning-node` dependency between `app` and `coordinator`

This `10101-lightning-node` is one of the aforementioned Rust crates shared between these two systems.
It represents the custom Lightning Node built using (a fork of) `rust-lightning` and `rust-dlc`.

### The `app`'s state will be controlled by its Rust backend

Thanks to this we should be able to write system tests against the `app`'s API without involving the frontend.

### The architecture will be similar to this component diagram

This diagram does include some of the assumptions listed above:

![Assumed component diagram](http://www.plantuml.com/plantuml/proxy?cache=no&src=)

## Strategy

In this section we describe the strategy that we recommend to follow when writing tests for this project.
Each subsection corresponds to a section of the codebase or a combination thereof.

### Common crates, `app` backend and `coordinator`

All this code is written in Rust.

#### Unit tests

Good unit testing patterns apply.
In particular, we strive for these tests to be small, structured[^1] and fast.
Unit tests will ideally only be written for pure functions.

They can be handy as API snapshot tests. For example, to ensure that a `serde` implementation doesn't change.

#### Integration tests

These are tests that depend on multiple components (perhaps across module boundaries).
Additionally, this kind of tests usually involve mocked state.

We are aiming to not spend too much time maintaining Rust integration tests, in favour of more comprehensive tests.

### The `app` frontend

This includes Flutter code (written in Dart) and the generated `flutter_rust_bridge`.
In practice, there shouldn't be a strong need to write tests for the `flutter_rust_bridge` code we write (Rust) since it wil be a thin layer.

#### Unit tests

We can apply similar principles as the ones mentioned for Rust code.

#### Widget tests

Used to verify Flutter widget appearance and behaviour.
They target a single widget.
The state is mocked i.e. no Rust called via `flutter_rust_bridge`.

#### Integration tests

These are your traditional "UI tests".
The clicks on the UI are simulated as if someone was using the application.

They remain lightweight as they only call to a mocked version of the API provided by `flutter_rust_bridge`.
We do not currently specify how this API shoud be mocked.
We considered (1) [mocking the dependency in Dart](https://docs.flutter.dev/cookbook/testing/unit/mocking) and (2) mocking the dependency in Rust.
We would prefer (1) as we think it would lead to simpler code than (2), but we are not sure if it's a feasible approach.

### System tests

These tests verify behaviour when multiple systems run in tandem.
When enough systems are involved, these might be referred to as end-to-end (e2e) tests.

#### Combinations

Here we list all the possible useful combinations we can imagine:

1. `App` backend + `coordinator`.
2. `App` backend + blockchain.
3. `Coordinator` + blockchain.
4. `App` backend + `coordinator` + blockchain.

Notably, the `app` frontend is excluded from system tests.
This is feasible if we ensure that the `app` frontend doesn't control important state for the `app`.

Thusly, we recommend that system tests involving the `app` backend be written in Dart.
These tests will be run using the [`dart test` command](https://dart.dev/tools/dart-test).
These tests will target the `flutter_rust_bridge` Dart API generated by the `app` backend.

The details of how the test environment should bet set up or consumed are not yet specified.
Regardless, we should aim to be able to conveniently run these tests locally by providing `docker-compose` files and/or setup scripts or by connecting to an always-available semi-public environment.

This document does not specify what type of Bitcoin blockchain these tests should run against.
We do believe it would be important to be able to run them against `signet` and `testnet`.

### Load tests

We should leverage a semi-public environment to assess the scalability of our solution.
This environment should not be misused for traditional system testing.

## Closing thoughts

Here we list what we think are the most important takeaways from this document:

- Manual testing is discouraged in favour of system tests and, separately, UI tests.
- We want to primarily write unit tests and system tests, a healthy dose of UI tests and not too many Rust integration tests.
- We do not want to engage in passive "testing" by way of automatically performing actions in a semi-public environment.
Basically, testing must involve pre-defined assertions.


[^1]: In the past, we've enjoyed writing unit tests that follow [the AAA pattern](https://blog.devgenius.io/the-three-as-of-unit-testing-3b8b4bf0d087).
